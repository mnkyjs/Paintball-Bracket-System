/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.1.0 (NJsonSchema v10.3.3.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { catchError as _observableCatch, mergeMap as _observableMergeMap } from 'rxjs/operators';
import { Observable, of as _observableOf, throwError as _observableThrow } from 'rxjs';
import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class PlanerService {
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
  private http: HttpClient;
  private baseUrl: string;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  login(body: UserForLoginDto | undefined): Observable<AuthModelDto> {
    let url_ = this.baseUrl + '/api/Auth/login';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        'Accept': 'text/plain'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processLogin(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLogin(<any> response_);
        } catch (e) {
          return <Observable<AuthModelDto>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<AuthModelDto>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @param body (optional)
   * @return Success
   */
  register(body: UserForRegisterDto | undefined): Observable<AuthModelDto> {
    let url_ = this.baseUrl + '/api/Auth/register';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        'Accept': 'text/plain'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processRegister(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processRegister(<any> response_);
        } catch (e) {
          return <Observable<AuthModelDto>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<AuthModelDto>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @param body (optional)
   * @return Success
   */
  postField(body: FieldDto | undefined): Observable<FieldDto> {
    let url_ = this.baseUrl + '/api/Field/create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        'Accept': 'text/plain'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processPostField(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPostField(<any> response_);
        } catch (e) {
          return <Observable<FieldDto>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<FieldDto>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @return Success
   */
  deleteField(id: number): Observable<void> {
    let url_ = this.baseUrl + '/api/Field/{id}';
    if (id === undefined || id === null) {
      throw new Error('The parameter \'id\' must be defined.');
    }
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({})
    };

    return this.http.request('delete', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteField(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteField(<any> response_);
        } catch (e) {
          return <Observable<void>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<void>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @return Success
   */
  getFieldById(id: number): Observable<FieldDto> {
    let url_ = this.baseUrl + '/api/Field/{id}';
    if (id === undefined || id === null) {
      throw new Error('The parameter \'id\' must be defined.');
    }
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Accept': 'text/plain'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetFieldById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetFieldById(<any> response_);
        } catch (e) {
          return <Observable<FieldDto>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<FieldDto>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateField(id: number, body: FieldDto | undefined): Observable<FieldDto> {
    let url_ = this.baseUrl + '/api/Field/{id}';
    if (id === undefined || id === null) {
      throw new Error('The parameter \'id\' must be defined.');
    }
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        'Accept': 'text/plain'
      })
    };

    return this.http.request('put', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processUpdateField(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdateField(<any> response_);
        } catch (e) {
          return <Observable<FieldDto>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<FieldDto>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @return Success
   */
  getFieldWithMatches(): Observable<FieldDto[]> {
    let url_ = this.baseUrl + '/api/Field/GetFieldWithMatches';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Accept': 'text/plain'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetFieldWithMatches(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetFieldWithMatches(<any> response_);
        } catch (e) {
          return <Observable<FieldDto[]>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<FieldDto[]>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @return Success
   */
  getListOfAllFields(): Observable<FieldDto[]> {
    let url_ = this.baseUrl + '/api/Field/GetListOfAllFields';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Accept': 'text/plain'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetListOfAllFields(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetListOfAllFields(<any> response_);
        } catch (e) {
          return <Observable<FieldDto[]>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<FieldDto[]>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @param body (optional)
   * @return Success
   */
  postLocation(body: Location | undefined): Observable<Location> {
    let url_ = this.baseUrl + '/api/Location';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        'Accept': 'text/plain'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processPostLocation(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPostLocation(<any> response_);
        } catch (e) {
          return <Observable<Location>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<Location>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @return Success
   */
  getListOfAllLocations(): Observable<LocationDto[]> {
    let url_ = this.baseUrl + '/api/Location';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Accept': 'text/plain'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetListOfAllLocations(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetListOfAllLocations(<any> response_);
        } catch (e) {
          return <Observable<LocationDto[]>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<LocationDto[]>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @param body (optional)
   * @return Success
   */
  deleteLocationById(id: string, body: Location | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/Location/{id}';
    if (id === undefined || id === null) {
      throw new Error('The parameter \'id\' must be defined.');
    }
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json'
      })
    };

    return this.http.request('delete', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteLocationById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteLocationById(<any> response_);
        } catch (e) {
          return <Observable<void>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<void>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @return Success
   */
  getLocationById(id: number): Observable<Location> {
    let url_ = this.baseUrl + '/api/Location/{id}';
    if (id === undefined || id === null) {
      throw new Error('The parameter \'id\' must be defined.');
    }
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Accept': 'text/plain'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetLocationById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetLocationById(<any> response_);
        } catch (e) {
          return <Observable<Location>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<Location>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateLocation(id: number, body: Location | undefined): Observable<Location> {
    let url_ = this.baseUrl + '/api/Location/{id}';
    if (id === undefined || id === null) {
      throw new Error('The parameter \'id\' must be defined.');
    }
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        'Accept': 'text/plain'
      })
    };

    return this.http.request('put', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processUpdateLocation(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdateLocation(<any> response_);
        } catch (e) {
          return <Observable<Location>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<Location>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createSchedule(body: CreateScheduleDto | undefined): Observable<TeamDto[][]> {
    let url_ = this.baseUrl + '/api/Match';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        'Accept': 'text/plain'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processCreateSchedule(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreateSchedule(<any> response_);
        } catch (e) {
          return <Observable<TeamDto[][]>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<TeamDto[][]>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @return Success
   */
  deleteAllMatch(): Observable<void> {
    let url_ = this.baseUrl + '/api/Match';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({})
    };

    return this.http.request('delete', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteAllMatch(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteAllMatch(<any> response_);
        } catch (e) {
          return <Observable<void>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<void>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @return Success
   */
  deleteMatch(time: Date, name: string | null): Observable<void> {
    let url_ = this.baseUrl + '/api/Match/{time}/{name}';
    if (time === undefined || time === null) {
      throw new Error('The parameter \'time\' must be defined.');
    }
    url_ = url_.replace('{time}', encodeURIComponent(time ? '' + time.toJSON() : 'null'));
    if (name === undefined || name === null) {
      throw new Error('The parameter \'name\' must be defined.');
    }
    url_ = url_.replace('{name}', encodeURIComponent('' + name));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({})
    };

    return this.http.request('delete', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteMatch(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteMatch(<any> response_);
        } catch (e) {
          return <Observable<void>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<void>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @param paintballfield (optional)
   * @return Success
   */
  getByField(paintballfield: number | undefined): Observable<BlockDto[]> {
    let url_ = this.baseUrl + '/api/Match/GetByField?';
    if (paintballfield === null) {
      throw new Error('The parameter \'paintballfield\' cannot be null.');
    } else if (paintballfield !== undefined) {
      url_ += 'paintballfield=' + encodeURIComponent('' + paintballfield) + '&';
    }
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Accept': 'text/plain'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetByField(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetByField(<any> response_);
        } catch (e) {
          return <Observable<BlockDto[]>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<BlockDto[]>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @return Success
   */
  getMatchesByGuid(guid: string | null): Observable<BlockDto[]> {
    let url_ = this.baseUrl + '/api/Match/{guid}';
    if (guid === undefined || guid === null) {
      throw new Error('The parameter \'guid\' must be defined.');
    }
    url_ = url_.replace('{guid}', encodeURIComponent('' + guid));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Accept': 'text/plain'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetMatchesByGuid(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetMatchesByGuid(<any> response_);
        } catch (e) {
          return <Observable<BlockDto[]>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<BlockDto[]>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @return Success
   */
  getAllRoles(): Observable<string[]> {
    let url_ = this.baseUrl + '/api/Role';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Accept': 'text/plain'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetAllRoles(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAllRoles(<any> response_);
        } catch (e) {
          return <Observable<string[]>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<string[]>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @param body (optional)
   * @return Success
   */
  postTeam(body: TeamDto | undefined): Observable<TeamDto> {
    let url_ = this.baseUrl + '/api/Teams';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        'Accept': 'text/plain'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processPostTeam(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPostTeam(<any> response_);
        } catch (e) {
          return <Observable<TeamDto>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<TeamDto>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @return Success
   */
  deleteTeam(id: number): Observable<void> {
    let url_ = this.baseUrl + '/api/Teams/{id}';
    if (id === undefined || id === null) {
      throw new Error('The parameter \'id\' must be defined.');
    }
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({})
    };

    return this.http.request('delete', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteTeam(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteTeam(<any> response_);
        } catch (e) {
          return <Observable<void>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<void>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @return Success
   */
  getTeamById(id: number): Observable<TeamDto> {
    let url_ = this.baseUrl + '/api/Teams/{id}';
    if (id === undefined || id === null) {
      throw new Error('The parameter \'id\' must be defined.');
    }
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Accept': 'text/plain'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetTeamById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetTeamById(<any> response_);
        } catch (e) {
          return <Observable<TeamDto>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<TeamDto>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateTeam(id: number, body: TeamDto | undefined): Observable<TeamDto> {
    let url_ = this.baseUrl + '/api/Teams/{id}';
    if (id === undefined || id === null) {
      throw new Error('The parameter \'id\' must be defined.');
    }
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        'Accept': 'text/plain'
      })
    };

    return this.http.request('put', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processUpdateTeam(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdateTeam(<any> response_);
        } catch (e) {
          return <Observable<TeamDto>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<TeamDto>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @param page (optional)
   * @param pageSize (optional)
   * @param filter (optional)
   * @param sortColumn (optional)
   * @param sortOrder (optional)
   * @return Success
   */
  getPagedListOfTeams(page: number | undefined, pageSize: number | undefined, filter: string | null | undefined, sortColumn: string | null | undefined, sortOrder: string | null | undefined): Observable<TeamPagedResult> {
    let url_ = this.baseUrl + '/api/Teams/GetPagedListOfTeams?';
    if (page === null) {
      throw new Error('The parameter \'page\' cannot be null.');
    } else if (page !== undefined) {
      url_ += 'page=' + encodeURIComponent('' + page) + '&';
    }
    if (pageSize === null) {
      throw new Error('The parameter \'pageSize\' cannot be null.');
    } else if (pageSize !== undefined) {
      url_ += 'pageSize=' + encodeURIComponent('' + pageSize) + '&';
    }
    if (filter !== undefined && filter !== null) {
      url_ += 'filter=' + encodeURIComponent('' + filter) + '&';
    }
    if (sortColumn !== undefined && sortColumn !== null) {
      url_ += 'sortColumn=' + encodeURIComponent('' + sortColumn) + '&';
    }
    if (sortOrder !== undefined && sortOrder !== null) {
      url_ += 'sortOrder=' + encodeURIComponent('' + sortOrder) + '&';
    }
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Accept': 'text/plain'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetPagedListOfTeams(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetPagedListOfTeams(<any> response_);
        } catch (e) {
          return <Observable<TeamPagedResult>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<TeamPagedResult>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @return Success
   */
  getListOfAllTeams(): Observable<TeamDto[]> {
    let url_ = this.baseUrl + '/api/Teams/GetListOfAllTeams';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Accept': 'text/plain'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetListOfAllTeams(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetListOfAllTeams(<any> response_);
        } catch (e) {
          return <Observable<TeamDto[]>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<TeamDto[]>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @return Success
   */
  deleteUser(id: number): Observable<void> {
    let url_ = this.baseUrl + '/api/Users/{id}';
    if (id === undefined || id === null) {
      throw new Error('The parameter \'id\' must be defined.');
    }
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({})
    };

    return this.http.request('delete', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteUser(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteUser(<any> response_);
        } catch (e) {
          return <Observable<void>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<void>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @return Success
   */
  getUserById(id: number): Observable<void> {
    let url_ = this.baseUrl + '/api/Users/{id}';
    if (id === undefined || id === null) {
      throw new Error('The parameter \'id\' must be defined.');
    }
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({})
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetUserById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetUserById(<any> response_);
        } catch (e) {
          return <Observable<void>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<void>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateUser(id: number, body: User | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/Users/{id}';
    if (id === undefined || id === null) {
      throw new Error('The parameter \'id\' must be defined.');
    }
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json'
      })
    };

    return this.http.request('put', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processUpdateUser(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdateUser(<any> response_);
        } catch (e) {
          return <Observable<void>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<void>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @param body (optional)
   * @return Success
   */
  editRoles(userName: string | null, body: RoleEditDto | undefined): Observable<string[]> {
    let url_ = this.baseUrl + '/api/Users/{userName}';
    if (userName === undefined || userName === null) {
      throw new Error('The parameter \'userName\' must be defined.');
    }
    url_ = url_.replace('{userName}', encodeURIComponent('' + userName));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        'Accept': 'text/plain'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processEditRoles(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processEditRoles(<any> response_);
        } catch (e) {
          return <Observable<string[]>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<string[]>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @return Success
   */
  getSharedMatches(): Observable<KeyPairValueDto[]> {
    let url_ = this.baseUrl + '/api/Users/GetSharedMatches';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Accept': 'text/plain'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetSharedMatches(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetSharedMatches(<any> response_);
        } catch (e) {
          return <Observable<KeyPairValueDto[]>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<KeyPairValueDto[]>> <any> _observableThrow(response_);
      }
    }));
  }

  /**
   * @return Success
   */
  getListOfUsers(): Observable<any[]> {
    let url_ = this.baseUrl + '/api/Users/GetListOfUsers';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Accept': 'text/plain'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetListOfUsers(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetListOfUsers(<any> response_);
        } catch (e) {
          return <Observable<any[]>> <any> _observableThrow(e);
        }
      } else {
        return <Observable<any[]>> <any> _observableThrow(response_);
      }
    }));
  }

  protected processLogin(response: HttpResponseBase): Observable<AuthModelDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <AuthModelDto> JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<AuthModelDto>(<any> null);
  }

  protected processRegister(response: HttpResponseBase): Observable<AuthModelDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <AuthModelDto> JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<AuthModelDto>(<any> null);
  }

  protected processPostField(response: HttpResponseBase): Observable<FieldDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <FieldDto> JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<FieldDto>(<any> null);
  }

  protected processDeleteField(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any> null);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('Unauthorized', status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('Forbidden', status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any> null);
  }

  protected processGetFieldById(response: HttpResponseBase): Observable<FieldDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <FieldDto> JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<FieldDto>(<any> null);
  }

  protected processUpdateField(response: HttpResponseBase): Observable<FieldDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <FieldDto> JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('Unauthorized', status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('Forbidden', status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<FieldDto>(<any> null);
  }

  protected processGetFieldWithMatches(response: HttpResponseBase): Observable<FieldDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <FieldDto[]> JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<FieldDto[]>(<any> null);
  }

  protected processGetListOfAllFields(response: HttpResponseBase): Observable<FieldDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <FieldDto[]> JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<FieldDto[]>(<any> null);
  }

  protected processPostLocation(response: HttpResponseBase): Observable<Location> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <Location> JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<Location>(<any> null);
  }

  protected processGetListOfAllLocations(response: HttpResponseBase): Observable<LocationDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <LocationDto[]> JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<LocationDto[]>(<any> null);
  }

  protected processDeleteLocationById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any> null);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any> null);
  }

  protected processGetLocationById(response: HttpResponseBase): Observable<Location> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <Location> JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<Location>(<any> null);
  }

  protected processUpdateLocation(response: HttpResponseBase): Observable<Location> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <Location> JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<Location>(<any> null);
  }

  protected processCreateSchedule(response: HttpResponseBase): Observable<TeamDto[][]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <TeamDto[][]> JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<TeamDto[][]>(<any> null);
  }

  protected processDeleteAllMatch(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any> null);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any> null);
  }

  protected processDeleteMatch(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any> null);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any> null);
  }

  protected processGetByField(response: HttpResponseBase): Observable<BlockDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <BlockDto[]> JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<BlockDto[]>(<any> null);
  }

  protected processGetMatchesByGuid(response: HttpResponseBase): Observable<BlockDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <BlockDto[]> JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<BlockDto[]>(<any> null);
  }

  protected processGetAllRoles(response: HttpResponseBase): Observable<string[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <string[]> JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<string[]>(<any> null);
  }

  protected processPostTeam(response: HttpResponseBase): Observable<TeamDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <TeamDto> JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<TeamDto>(<any> null);
  }

  protected processDeleteTeam(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any> null);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any> null);
  }

  protected processGetTeamById(response: HttpResponseBase): Observable<TeamDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <TeamDto> JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<TeamDto>(<any> null);
  }

  protected processUpdateTeam(response: HttpResponseBase): Observable<TeamDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <TeamDto> JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('Unauthorized', status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('Forbidden', status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<TeamDto>(<any> null);
  }

  protected processGetPagedListOfTeams(response: HttpResponseBase): Observable<TeamPagedResult> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <TeamPagedResult> JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<TeamPagedResult>(<any> null);
  }

  protected processGetListOfAllTeams(response: HttpResponseBase): Observable<TeamDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <TeamDto[]> JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<TeamDto[]>(<any> null);
  }

  protected processDeleteUser(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any> null);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('Unauthorized', status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('Forbidden', status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any> null);
  }

  protected processGetUserById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any> null);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any> null);
  }

  protected processUpdateUser(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any> null);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('Unauthorized', status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('Forbidden', status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any> null);
  }

  protected processEditRoles(response: HttpResponseBase): Observable<string[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <string[]> JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('Unauthorized', status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('Forbidden', status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<string[]>(<any> null);
  }

  protected processGetSharedMatches(response: HttpResponseBase): Observable<KeyPairValueDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <KeyPairValueDto[]> JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<KeyPairValueDto[]>(<any> null);
  }

  protected processGetListOfUsers(response: HttpResponseBase): Observable<any[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any> response).error instanceof Blob ? (<any> response).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <any[]> JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('Unauthorized', status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('Forbidden', status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<any[]>(<any> null);
  }
}

export interface UserForLoginDto {
  username?: string | undefined;
  password?: string | undefined;
}

export interface AuthModelDto {
  token?: string | undefined;
}

export interface UserForRegisterDto {
  password: string;
  teamName?: string | undefined;
  userName: string;
}

export interface KeyPairValueDto {
  name?: string | undefined;
  guid?: string | undefined;
  date?: Date;
}

export interface FieldDto {
  id?: number;
  name?: string | undefined;
  street?: string | undefined;
  houseNumber?: string | undefined;
  postalCode?: number;
  place?: string | undefined;
  phoneNumber?: string | undefined;
  locationId?: number;
  nameAndDate?: KeyPairValueDto[] | undefined;
}

export interface Match {
  id?: number;
  matchName?: string | undefined;
  date?: Date | undefined;
  guid?: string | undefined;
  teamAId?: number;
  teamA?: Team;
  teamBId?: number;
  teamB?: Team;
  user?: User;
  paintballfieldId?: number;
  paintballfield?: Paintballfield;
}

export interface Team {
  id?: number;
  name?: string | undefined;
  creatorId?: number;
  creator?: User;
  matchesTeamA?: Match[] | undefined;
  matchesTeamB?: Match[] | undefined;
}

export interface Role {
  id?: number;
  name?: string | undefined;
  normalizedName?: string | undefined;
  concurrencyStamp?: string | undefined;
  userRoles?: UserRole[] | undefined;
}

export interface UserRole {
  userId?: number;
  roleId?: number;
  user?: User;
  role?: Role;
}

export interface User {
  id?: number;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;
  created?: Date;
  paintballFields?: Paintballfield[] | undefined;
  teams?: Team[] | undefined;
  teamName?: string | undefined;
  userRoles?: UserRole[] | undefined;
}

export interface Paintballfield {
  id?: number;
  name?: string | undefined;
  street?: string | undefined;
  houseNumber?: string | undefined;
  postalCode?: number;
  place?: string | undefined;
  phoneNumber?: string | undefined;
  locationId?: number;
  location?: Location;
  creatorId?: number;
  creator?: User;
  matches?: Match[] | undefined;
}

export interface Location {
  id?: number;
  name?: string | undefined;
  paintballfields?: Paintballfield[] | undefined;
}

export interface LocationDto {
  id?: number;
  name?: string | undefined;
}

export interface CreateScheduleDto {
  addClashToAnExistingOne?: boolean;
  date?: string | undefined;
  teams?: Team[] | undefined;
  paintballfieldId?: number;
  name?: string | undefined;
}

export interface UserFlatDto {
  teamName?: string | undefined;
  userName?: string | undefined;
}

export interface TeamDto {
  id?: number;
  user?: UserFlatDto;
  name: string;
}

export interface BlockDto {
  blockNumber?: number;
  games?: string[] | undefined;
}

export interface MetaData {
  currentPage?: number;
  totalPages?: number;
  pageSize?: number;
  totalCount?: number;
  readonly hasPrevious?: boolean;
  readonly hasNext?: boolean;
}

export interface TeamPagedResult {
  readonly items?: Team[] | undefined;
  metaData?: MetaData;
}

export interface RoleEditDto {
  roleNames?: string[] | undefined;
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any; };
  result: any;
  protected isApiException = true;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
  if (result !== null && result !== undefined) {
    return _observableThrow(result);
  } else {
    return _observableThrow(new ApiException(message, status, response, headers, null));
  }
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next("");
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = event => {
        observer.next((<any> event.target).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
